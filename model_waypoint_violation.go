/*
Kardinal ARO API

This document specifies the REST API of Kardinal ARO v2.

API version: 2.45.0
Contact: contact@kardinal.ai
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// WaypointViolation - Semantic violations, can be handled \"generically\" or specifically.
type WaypointViolation struct {
	AtLeastOneValidCapacityViolation *AtLeastOneValidCapacityViolation
	AuthorizedTimeWindowViolation *AuthorizedTimeWindowViolation
	BeginViolation *BeginViolation
	CapacityViolation *CapacityViolation
	EndViolation *EndViolation
	ForbiddenAssignmentViolation *ForbiddenAssignmentViolation
	SkillsViolation *SkillsViolation
}

// AtLeastOneValidCapacityViolationAsWaypointViolation is a convenience function that returns AtLeastOneValidCapacityViolation wrapped in WaypointViolation
func AtLeastOneValidCapacityViolationAsWaypointViolation(v *AtLeastOneValidCapacityViolation) WaypointViolation {
	return WaypointViolation{
		AtLeastOneValidCapacityViolation: v,
	}
}

// AuthorizedTimeWindowViolationAsWaypointViolation is a convenience function that returns AuthorizedTimeWindowViolation wrapped in WaypointViolation
func AuthorizedTimeWindowViolationAsWaypointViolation(v *AuthorizedTimeWindowViolation) WaypointViolation {
	return WaypointViolation{
		AuthorizedTimeWindowViolation: v,
	}
}

// BeginViolationAsWaypointViolation is a convenience function that returns BeginViolation wrapped in WaypointViolation
func BeginViolationAsWaypointViolation(v *BeginViolation) WaypointViolation {
	return WaypointViolation{
		BeginViolation: v,
	}
}

// CapacityViolationAsWaypointViolation is a convenience function that returns CapacityViolation wrapped in WaypointViolation
func CapacityViolationAsWaypointViolation(v *CapacityViolation) WaypointViolation {
	return WaypointViolation{
		CapacityViolation: v,
	}
}

// EndViolationAsWaypointViolation is a convenience function that returns EndViolation wrapped in WaypointViolation
func EndViolationAsWaypointViolation(v *EndViolation) WaypointViolation {
	return WaypointViolation{
		EndViolation: v,
	}
}

// ForbiddenAssignmentViolationAsWaypointViolation is a convenience function that returns ForbiddenAssignmentViolation wrapped in WaypointViolation
func ForbiddenAssignmentViolationAsWaypointViolation(v *ForbiddenAssignmentViolation) WaypointViolation {
	return WaypointViolation{
		ForbiddenAssignmentViolation: v,
	}
}

// SkillsViolationAsWaypointViolation is a convenience function that returns SkillsViolation wrapped in WaypointViolation
func SkillsViolationAsWaypointViolation(v *SkillsViolation) WaypointViolation {
	return WaypointViolation{
		SkillsViolation: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *WaypointViolation) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AtLeastOneValidCapacityViolation
	err = newStrictDecoder(data).Decode(&dst.AtLeastOneValidCapacityViolation)
	if err == nil {
		jsonAtLeastOneValidCapacityViolation, _ := json.Marshal(dst.AtLeastOneValidCapacityViolation)
		if string(jsonAtLeastOneValidCapacityViolation) == "{}" { // empty struct
			dst.AtLeastOneValidCapacityViolation = nil
		} else {
			if err = validator.Validate(dst.AtLeastOneValidCapacityViolation); err != nil {
				dst.AtLeastOneValidCapacityViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.AtLeastOneValidCapacityViolation = nil
	}

	// try to unmarshal data into AuthorizedTimeWindowViolation
	err = newStrictDecoder(data).Decode(&dst.AuthorizedTimeWindowViolation)
	if err == nil {
		jsonAuthorizedTimeWindowViolation, _ := json.Marshal(dst.AuthorizedTimeWindowViolation)
		if string(jsonAuthorizedTimeWindowViolation) == "{}" { // empty struct
			dst.AuthorizedTimeWindowViolation = nil
		} else {
			if err = validator.Validate(dst.AuthorizedTimeWindowViolation); err != nil {
				dst.AuthorizedTimeWindowViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.AuthorizedTimeWindowViolation = nil
	}

	// try to unmarshal data into BeginViolation
	err = newStrictDecoder(data).Decode(&dst.BeginViolation)
	if err == nil {
		jsonBeginViolation, _ := json.Marshal(dst.BeginViolation)
		if string(jsonBeginViolation) == "{}" { // empty struct
			dst.BeginViolation = nil
		} else {
			if err = validator.Validate(dst.BeginViolation); err != nil {
				dst.BeginViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.BeginViolation = nil
	}

	// try to unmarshal data into CapacityViolation
	err = newStrictDecoder(data).Decode(&dst.CapacityViolation)
	if err == nil {
		jsonCapacityViolation, _ := json.Marshal(dst.CapacityViolation)
		if string(jsonCapacityViolation) == "{}" { // empty struct
			dst.CapacityViolation = nil
		} else {
			if err = validator.Validate(dst.CapacityViolation); err != nil {
				dst.CapacityViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.CapacityViolation = nil
	}

	// try to unmarshal data into EndViolation
	err = newStrictDecoder(data).Decode(&dst.EndViolation)
	if err == nil {
		jsonEndViolation, _ := json.Marshal(dst.EndViolation)
		if string(jsonEndViolation) == "{}" { // empty struct
			dst.EndViolation = nil
		} else {
			if err = validator.Validate(dst.EndViolation); err != nil {
				dst.EndViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.EndViolation = nil
	}

	// try to unmarshal data into ForbiddenAssignmentViolation
	err = newStrictDecoder(data).Decode(&dst.ForbiddenAssignmentViolation)
	if err == nil {
		jsonForbiddenAssignmentViolation, _ := json.Marshal(dst.ForbiddenAssignmentViolation)
		if string(jsonForbiddenAssignmentViolation) == "{}" { // empty struct
			dst.ForbiddenAssignmentViolation = nil
		} else {
			if err = validator.Validate(dst.ForbiddenAssignmentViolation); err != nil {
				dst.ForbiddenAssignmentViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.ForbiddenAssignmentViolation = nil
	}

	// try to unmarshal data into SkillsViolation
	err = newStrictDecoder(data).Decode(&dst.SkillsViolation)
	if err == nil {
		jsonSkillsViolation, _ := json.Marshal(dst.SkillsViolation)
		if string(jsonSkillsViolation) == "{}" { // empty struct
			dst.SkillsViolation = nil
		} else {
			if err = validator.Validate(dst.SkillsViolation); err != nil {
				dst.SkillsViolation = nil
			} else {
				match++
			}
		}
	} else {
		dst.SkillsViolation = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AtLeastOneValidCapacityViolation = nil
		dst.AuthorizedTimeWindowViolation = nil
		dst.BeginViolation = nil
		dst.CapacityViolation = nil
		dst.EndViolation = nil
		dst.ForbiddenAssignmentViolation = nil
		dst.SkillsViolation = nil

		return fmt.Errorf("data matches more than one schema in oneOf(WaypointViolation)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(WaypointViolation)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src WaypointViolation) MarshalJSON() ([]byte, error) {
	if src.AtLeastOneValidCapacityViolation != nil {
		return json.Marshal(&src.AtLeastOneValidCapacityViolation)
	}

	if src.AuthorizedTimeWindowViolation != nil {
		return json.Marshal(&src.AuthorizedTimeWindowViolation)
	}

	if src.BeginViolation != nil {
		return json.Marshal(&src.BeginViolation)
	}

	if src.CapacityViolation != nil {
		return json.Marshal(&src.CapacityViolation)
	}

	if src.EndViolation != nil {
		return json.Marshal(&src.EndViolation)
	}

	if src.ForbiddenAssignmentViolation != nil {
		return json.Marshal(&src.ForbiddenAssignmentViolation)
	}

	if src.SkillsViolation != nil {
		return json.Marshal(&src.SkillsViolation)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *WaypointViolation) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AtLeastOneValidCapacityViolation != nil {
		return obj.AtLeastOneValidCapacityViolation
	}

	if obj.AuthorizedTimeWindowViolation != nil {
		return obj.AuthorizedTimeWindowViolation
	}

	if obj.BeginViolation != nil {
		return obj.BeginViolation
	}

	if obj.CapacityViolation != nil {
		return obj.CapacityViolation
	}

	if obj.EndViolation != nil {
		return obj.EndViolation
	}

	if obj.ForbiddenAssignmentViolation != nil {
		return obj.ForbiddenAssignmentViolation
	}

	if obj.SkillsViolation != nil {
		return obj.SkillsViolation
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj WaypointViolation) GetActualInstanceValue() (interface{}) {
	if obj.AtLeastOneValidCapacityViolation != nil {
		return *obj.AtLeastOneValidCapacityViolation
	}

	if obj.AuthorizedTimeWindowViolation != nil {
		return *obj.AuthorizedTimeWindowViolation
	}

	if obj.BeginViolation != nil {
		return *obj.BeginViolation
	}

	if obj.CapacityViolation != nil {
		return *obj.CapacityViolation
	}

	if obj.EndViolation != nil {
		return *obj.EndViolation
	}

	if obj.ForbiddenAssignmentViolation != nil {
		return *obj.ForbiddenAssignmentViolation
	}

	if obj.SkillsViolation != nil {
		return *obj.SkillsViolation
	}

	// all schemas are nil
	return nil
}

type NullableWaypointViolation struct {
	value *WaypointViolation
	isSet bool
}

func (v NullableWaypointViolation) Get() *WaypointViolation {
	return v.value
}

func (v *NullableWaypointViolation) Set(val *WaypointViolation) {
	v.value = val
	v.isSet = true
}

func (v NullableWaypointViolation) IsSet() bool {
	return v.isSet
}

func (v *NullableWaypointViolation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWaypointViolation(val *WaypointViolation) *NullableWaypointViolation {
	return &NullableWaypointViolation{value: val, isSet: true}
}

func (v NullableWaypointViolation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWaypointViolation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


