/*
Kardinal ARO API

This document specifies the REST API of Kardinal ARO v2.

API version: 2.45.0
Contact: contact@kardinal.ai
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the SMAInput type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SMAInput{}

// SMAInput struct for SMAInput
type SMAInput struct {
	Order SMAOrder `json:"order"`
	MaxNbPropositions NullableInt32 `json:"maxNbPropositions,omitempty"`
	TimeWindows []TimeWindow `json:"timeWindows"`
	// The time zone is a string code which identifies a region of the world in the \"time zone database\", also called \"tz database\". The tz database is a partition of the world into regions where local clocks all show the same time. This database gives the rules for time offset and daylight saving time in each region.  How do we use it?  In order to work with time events accurately, we usually use datetimes in the iso-8601 format, without explicit time zone. This format is quite well suported by many programming languages, and it is well suited for technical data exchange. But it is not easy to use for humans.  For instance, here are three datetimes in iso-8601 format, which give the same exact moment in time: - \"2025-05-22T05:43:00Z\" - \"2025-05-22T06:43:00+01:00\" - \"2025-05-22T07:43:00+02:00\"  For a non-technical user, it is difficult to know how to relate this to the time displayed on a watch or a clock.  We improve the user experience by adding the support of local datetimes, thanks to the use of the time zone, which allows to transform a local datetime into an iso-8601 datetime: - local datetime + timezone (tz) = iso-8601 datetime  For instance, here are five datetimes which all give the same exact moment in time: - \"2025-05-22T05:43:00Z\" - \"2025-05-22T06:43:00+01:00\" - \"2025-05-22T07:43:00+02:00\" - \"2025-05-22 07:43:00\"       + timezone \"tz\": \"Europe/Paris\" - \"2025-05-22 07:43\"          + timezone \"tz\": \"Europe/Paris\"  Note: the last example (\"2025-05-22 07:43\") illustrates the support of local datetimes without seconds, which can be very practical for users.  In order for local datetimes to be supported, some JSON input objects contain a \"tz\" time zone property. This \"tz\" property is used to pre-process the JSON input payload, like this: - We check if a valid timezone can be extracted from the \"tz\" property, - If so, we perform the following actions:   - Walk through the whole JSON content to look for local datetimes,   - Use the timezone to transform each local datetime into an iso-8601 datetime.  Important: some objects contain a \"properties\" sub-object, which is a map of custom client data; the content of the \"properties\" sub-objects is always excluded from the time zone pre-processing. 
	Tz *string `json:"tz,omitempty"`
}

type _SMAInput SMAInput

// NewSMAInput instantiates a new SMAInput object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSMAInput(order SMAOrder, timeWindows []TimeWindow) *SMAInput {
	this := SMAInput{}
	this.Order = order
	this.TimeWindows = timeWindows
	return &this
}

// NewSMAInputWithDefaults instantiates a new SMAInput object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSMAInputWithDefaults() *SMAInput {
	this := SMAInput{}
	return &this
}

// GetOrder returns the Order field value
func (o *SMAInput) GetOrder() SMAOrder {
	if o == nil {
		var ret SMAOrder
		return ret
	}

	return o.Order
}

// GetOrderOk returns a tuple with the Order field value
// and a boolean to check if the value has been set.
func (o *SMAInput) GetOrderOk() (*SMAOrder, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Order, true
}

// SetOrder sets field value
func (o *SMAInput) SetOrder(v SMAOrder) {
	o.Order = v
}

// GetMaxNbPropositions returns the MaxNbPropositions field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SMAInput) GetMaxNbPropositions() int32 {
	if o == nil || IsNil(o.MaxNbPropositions.Get()) {
		var ret int32
		return ret
	}
	return *o.MaxNbPropositions.Get()
}

// GetMaxNbPropositionsOk returns a tuple with the MaxNbPropositions field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SMAInput) GetMaxNbPropositionsOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.MaxNbPropositions.Get(), o.MaxNbPropositions.IsSet()
}

// HasMaxNbPropositions returns a boolean if a field has been set.
func (o *SMAInput) HasMaxNbPropositions() bool {
	if o != nil && o.MaxNbPropositions.IsSet() {
		return true
	}

	return false
}

// SetMaxNbPropositions gets a reference to the given NullableInt32 and assigns it to the MaxNbPropositions field.
func (o *SMAInput) SetMaxNbPropositions(v int32) {
	o.MaxNbPropositions.Set(&v)
}
// SetMaxNbPropositionsNil sets the value for MaxNbPropositions to be an explicit nil
func (o *SMAInput) SetMaxNbPropositionsNil() {
	o.MaxNbPropositions.Set(nil)
}

// UnsetMaxNbPropositions ensures that no value is present for MaxNbPropositions, not even an explicit nil
func (o *SMAInput) UnsetMaxNbPropositions() {
	o.MaxNbPropositions.Unset()
}

// GetTimeWindows returns the TimeWindows field value
func (o *SMAInput) GetTimeWindows() []TimeWindow {
	if o == nil {
		var ret []TimeWindow
		return ret
	}

	return o.TimeWindows
}

// GetTimeWindowsOk returns a tuple with the TimeWindows field value
// and a boolean to check if the value has been set.
func (o *SMAInput) GetTimeWindowsOk() ([]TimeWindow, bool) {
	if o == nil {
		return nil, false
	}
	return o.TimeWindows, true
}

// SetTimeWindows sets field value
func (o *SMAInput) SetTimeWindows(v []TimeWindow) {
	o.TimeWindows = v
}

// GetTz returns the Tz field value if set, zero value otherwise.
func (o *SMAInput) GetTz() string {
	if o == nil || IsNil(o.Tz) {
		var ret string
		return ret
	}
	return *o.Tz
}

// GetTzOk returns a tuple with the Tz field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SMAInput) GetTzOk() (*string, bool) {
	if o == nil || IsNil(o.Tz) {
		return nil, false
	}
	return o.Tz, true
}

// HasTz returns a boolean if a field has been set.
func (o *SMAInput) HasTz() bool {
	if o != nil && !IsNil(o.Tz) {
		return true
	}

	return false
}

// SetTz gets a reference to the given string and assigns it to the Tz field.
func (o *SMAInput) SetTz(v string) {
	o.Tz = &v
}

func (o SMAInput) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SMAInput) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["order"] = o.Order
	if o.MaxNbPropositions.IsSet() {
		toSerialize["maxNbPropositions"] = o.MaxNbPropositions.Get()
	}
	toSerialize["timeWindows"] = o.TimeWindows
	if !IsNil(o.Tz) {
		toSerialize["tz"] = o.Tz
	}
	return toSerialize, nil
}

func (o *SMAInput) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"order",
		"timeWindows",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varSMAInput := _SMAInput{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varSMAInput)

	if err != nil {
		return err
	}

	*o = SMAInput(varSMAInput)

	return err
}

type NullableSMAInput struct {
	value *SMAInput
	isSet bool
}

func (v NullableSMAInput) Get() *SMAInput {
	return v.value
}

func (v *NullableSMAInput) Set(val *SMAInput) {
	v.value = val
	v.isSet = true
}

func (v NullableSMAInput) IsSet() bool {
	return v.isSet
}

func (v *NullableSMAInput) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSMAInput(val *SMAInput) *NullableSMAInput {
	return &NullableSMAInput{value: val, isSet: true}
}

func (v NullableSMAInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSMAInput) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


