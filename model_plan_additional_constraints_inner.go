/*
Kardinal ARO API

This document specifies the REST API of Kardinal ARO v2.

API version: 2.45.0
Contact: contact@kardinal.ai
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// PlanAdditionalConstraintsInner - struct for PlanAdditionalConstraintsInner
type PlanAdditionalConstraintsInner struct {
	AdditionalConstraintAtLeastOneConstraint *AdditionalConstraintAtLeastOneConstraint
	AdditionalConstraintAtLeastOneValidCapacity *AdditionalConstraintAtLeastOneValidCapacity
	AdditionalConstraintCapacities *AdditionalConstraintCapacities
	AdditionalConstraintForbiddenAssignment *AdditionalConstraintForbiddenAssignment
	AdditionalConstraintIncompatibleStopTags *AdditionalConstraintIncompatibleStopTags
	AdditionalConstraintMaxStopTagGroups *AdditionalConstraintMaxStopTagGroups
	AdditionalConstraintRemovalStrategy *AdditionalConstraintRemovalStrategy
}

// AdditionalConstraintAtLeastOneConstraintAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintAtLeastOneConstraint wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintAtLeastOneConstraintAsPlanAdditionalConstraintsInner(v *AdditionalConstraintAtLeastOneConstraint) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintAtLeastOneConstraint: v,
	}
}

// AdditionalConstraintAtLeastOneValidCapacityAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintAtLeastOneValidCapacity wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintAtLeastOneValidCapacityAsPlanAdditionalConstraintsInner(v *AdditionalConstraintAtLeastOneValidCapacity) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintAtLeastOneValidCapacity: v,
	}
}

// AdditionalConstraintCapacitiesAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintCapacities wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintCapacitiesAsPlanAdditionalConstraintsInner(v *AdditionalConstraintCapacities) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintCapacities: v,
	}
}

// AdditionalConstraintForbiddenAssignmentAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintForbiddenAssignment wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintForbiddenAssignmentAsPlanAdditionalConstraintsInner(v *AdditionalConstraintForbiddenAssignment) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintForbiddenAssignment: v,
	}
}

// AdditionalConstraintIncompatibleStopTagsAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintIncompatibleStopTags wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintIncompatibleStopTagsAsPlanAdditionalConstraintsInner(v *AdditionalConstraintIncompatibleStopTags) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintIncompatibleStopTags: v,
	}
}

// AdditionalConstraintMaxStopTagGroupsAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintMaxStopTagGroups wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintMaxStopTagGroupsAsPlanAdditionalConstraintsInner(v *AdditionalConstraintMaxStopTagGroups) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintMaxStopTagGroups: v,
	}
}

// AdditionalConstraintRemovalStrategyAsPlanAdditionalConstraintsInner is a convenience function that returns AdditionalConstraintRemovalStrategy wrapped in PlanAdditionalConstraintsInner
func AdditionalConstraintRemovalStrategyAsPlanAdditionalConstraintsInner(v *AdditionalConstraintRemovalStrategy) PlanAdditionalConstraintsInner {
	return PlanAdditionalConstraintsInner{
		AdditionalConstraintRemovalStrategy: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *PlanAdditionalConstraintsInner) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AdditionalConstraintAtLeastOneConstraint
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintAtLeastOneConstraint)
	if err == nil {
		jsonAdditionalConstraintAtLeastOneConstraint, _ := json.Marshal(dst.AdditionalConstraintAtLeastOneConstraint)
		if string(jsonAdditionalConstraintAtLeastOneConstraint) == "{}" { // empty struct
			dst.AdditionalConstraintAtLeastOneConstraint = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintAtLeastOneConstraint); err != nil {
				dst.AdditionalConstraintAtLeastOneConstraint = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintAtLeastOneConstraint = nil
	}

	// try to unmarshal data into AdditionalConstraintAtLeastOneValidCapacity
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintAtLeastOneValidCapacity)
	if err == nil {
		jsonAdditionalConstraintAtLeastOneValidCapacity, _ := json.Marshal(dst.AdditionalConstraintAtLeastOneValidCapacity)
		if string(jsonAdditionalConstraintAtLeastOneValidCapacity) == "{}" { // empty struct
			dst.AdditionalConstraintAtLeastOneValidCapacity = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintAtLeastOneValidCapacity); err != nil {
				dst.AdditionalConstraintAtLeastOneValidCapacity = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintAtLeastOneValidCapacity = nil
	}

	// try to unmarshal data into AdditionalConstraintCapacities
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintCapacities)
	if err == nil {
		jsonAdditionalConstraintCapacities, _ := json.Marshal(dst.AdditionalConstraintCapacities)
		if string(jsonAdditionalConstraintCapacities) == "{}" { // empty struct
			dst.AdditionalConstraintCapacities = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintCapacities); err != nil {
				dst.AdditionalConstraintCapacities = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintCapacities = nil
	}

	// try to unmarshal data into AdditionalConstraintForbiddenAssignment
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintForbiddenAssignment)
	if err == nil {
		jsonAdditionalConstraintForbiddenAssignment, _ := json.Marshal(dst.AdditionalConstraintForbiddenAssignment)
		if string(jsonAdditionalConstraintForbiddenAssignment) == "{}" { // empty struct
			dst.AdditionalConstraintForbiddenAssignment = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintForbiddenAssignment); err != nil {
				dst.AdditionalConstraintForbiddenAssignment = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintForbiddenAssignment = nil
	}

	// try to unmarshal data into AdditionalConstraintIncompatibleStopTags
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintIncompatibleStopTags)
	if err == nil {
		jsonAdditionalConstraintIncompatibleStopTags, _ := json.Marshal(dst.AdditionalConstraintIncompatibleStopTags)
		if string(jsonAdditionalConstraintIncompatibleStopTags) == "{}" { // empty struct
			dst.AdditionalConstraintIncompatibleStopTags = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintIncompatibleStopTags); err != nil {
				dst.AdditionalConstraintIncompatibleStopTags = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintIncompatibleStopTags = nil
	}

	// try to unmarshal data into AdditionalConstraintMaxStopTagGroups
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintMaxStopTagGroups)
	if err == nil {
		jsonAdditionalConstraintMaxStopTagGroups, _ := json.Marshal(dst.AdditionalConstraintMaxStopTagGroups)
		if string(jsonAdditionalConstraintMaxStopTagGroups) == "{}" { // empty struct
			dst.AdditionalConstraintMaxStopTagGroups = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintMaxStopTagGroups); err != nil {
				dst.AdditionalConstraintMaxStopTagGroups = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintMaxStopTagGroups = nil
	}

	// try to unmarshal data into AdditionalConstraintRemovalStrategy
	err = newStrictDecoder(data).Decode(&dst.AdditionalConstraintRemovalStrategy)
	if err == nil {
		jsonAdditionalConstraintRemovalStrategy, _ := json.Marshal(dst.AdditionalConstraintRemovalStrategy)
		if string(jsonAdditionalConstraintRemovalStrategy) == "{}" { // empty struct
			dst.AdditionalConstraintRemovalStrategy = nil
		} else {
			if err = validator.Validate(dst.AdditionalConstraintRemovalStrategy); err != nil {
				dst.AdditionalConstraintRemovalStrategy = nil
			} else {
				match++
			}
		}
	} else {
		dst.AdditionalConstraintRemovalStrategy = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AdditionalConstraintAtLeastOneConstraint = nil
		dst.AdditionalConstraintAtLeastOneValidCapacity = nil
		dst.AdditionalConstraintCapacities = nil
		dst.AdditionalConstraintForbiddenAssignment = nil
		dst.AdditionalConstraintIncompatibleStopTags = nil
		dst.AdditionalConstraintMaxStopTagGroups = nil
		dst.AdditionalConstraintRemovalStrategy = nil

		return fmt.Errorf("data matches more than one schema in oneOf(PlanAdditionalConstraintsInner)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(PlanAdditionalConstraintsInner)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src PlanAdditionalConstraintsInner) MarshalJSON() ([]byte, error) {
	if src.AdditionalConstraintAtLeastOneConstraint != nil {
		return json.Marshal(&src.AdditionalConstraintAtLeastOneConstraint)
	}

	if src.AdditionalConstraintAtLeastOneValidCapacity != nil {
		return json.Marshal(&src.AdditionalConstraintAtLeastOneValidCapacity)
	}

	if src.AdditionalConstraintCapacities != nil {
		return json.Marshal(&src.AdditionalConstraintCapacities)
	}

	if src.AdditionalConstraintForbiddenAssignment != nil {
		return json.Marshal(&src.AdditionalConstraintForbiddenAssignment)
	}

	if src.AdditionalConstraintIncompatibleStopTags != nil {
		return json.Marshal(&src.AdditionalConstraintIncompatibleStopTags)
	}

	if src.AdditionalConstraintMaxStopTagGroups != nil {
		return json.Marshal(&src.AdditionalConstraintMaxStopTagGroups)
	}

	if src.AdditionalConstraintRemovalStrategy != nil {
		return json.Marshal(&src.AdditionalConstraintRemovalStrategy)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *PlanAdditionalConstraintsInner) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AdditionalConstraintAtLeastOneConstraint != nil {
		return obj.AdditionalConstraintAtLeastOneConstraint
	}

	if obj.AdditionalConstraintAtLeastOneValidCapacity != nil {
		return obj.AdditionalConstraintAtLeastOneValidCapacity
	}

	if obj.AdditionalConstraintCapacities != nil {
		return obj.AdditionalConstraintCapacities
	}

	if obj.AdditionalConstraintForbiddenAssignment != nil {
		return obj.AdditionalConstraintForbiddenAssignment
	}

	if obj.AdditionalConstraintIncompatibleStopTags != nil {
		return obj.AdditionalConstraintIncompatibleStopTags
	}

	if obj.AdditionalConstraintMaxStopTagGroups != nil {
		return obj.AdditionalConstraintMaxStopTagGroups
	}

	if obj.AdditionalConstraintRemovalStrategy != nil {
		return obj.AdditionalConstraintRemovalStrategy
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj PlanAdditionalConstraintsInner) GetActualInstanceValue() (interface{}) {
	if obj.AdditionalConstraintAtLeastOneConstraint != nil {
		return *obj.AdditionalConstraintAtLeastOneConstraint
	}

	if obj.AdditionalConstraintAtLeastOneValidCapacity != nil {
		return *obj.AdditionalConstraintAtLeastOneValidCapacity
	}

	if obj.AdditionalConstraintCapacities != nil {
		return *obj.AdditionalConstraintCapacities
	}

	if obj.AdditionalConstraintForbiddenAssignment != nil {
		return *obj.AdditionalConstraintForbiddenAssignment
	}

	if obj.AdditionalConstraintIncompatibleStopTags != nil {
		return *obj.AdditionalConstraintIncompatibleStopTags
	}

	if obj.AdditionalConstraintMaxStopTagGroups != nil {
		return *obj.AdditionalConstraintMaxStopTagGroups
	}

	if obj.AdditionalConstraintRemovalStrategy != nil {
		return *obj.AdditionalConstraintRemovalStrategy
	}

	// all schemas are nil
	return nil
}

type NullablePlanAdditionalConstraintsInner struct {
	value *PlanAdditionalConstraintsInner
	isSet bool
}

func (v NullablePlanAdditionalConstraintsInner) Get() *PlanAdditionalConstraintsInner {
	return v.value
}

func (v *NullablePlanAdditionalConstraintsInner) Set(val *PlanAdditionalConstraintsInner) {
	v.value = val
	v.isSet = true
}

func (v NullablePlanAdditionalConstraintsInner) IsSet() bool {
	return v.isSet
}

func (v *NullablePlanAdditionalConstraintsInner) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePlanAdditionalConstraintsInner(val *PlanAdditionalConstraintsInner) *NullablePlanAdditionalConstraintsInner {
	return &NullablePlanAdditionalConstraintsInner{value: val, isSet: true}
}

func (v NullablePlanAdditionalConstraintsInner) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePlanAdditionalConstraintsInner) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


